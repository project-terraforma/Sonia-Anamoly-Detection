"""
Unified AI Agent Comparison Dashboard
=====================================
Combines rule-based synthesis with AI-driven pattern discovery.

Features:
- Synthesizes rule-based alerts into patterns
- Discovers patterns rules may have missed
- Geographic concentration analysis
- Confidence scores per finding
- Root cause identification
- Actionable recommendations

Usage:
    python anomaly_detector.py Metrics/ --json anomalies.json
    python comparison_dashboard.py --input anomalies.json -o dashboard.html
"""

import json
import os
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional

# Try to import Anthropic
try:
    from anthropic import Anthropic
    HAS_ANTHROPIC = True
except ImportError:
    HAS_ANTHROPIC = False


def load_anomalies_from_json(json_path: Path) -> dict:
    """Load anomalies from a JSON file generated by anomaly_detector.py"""
    with open(json_path) as f:
        data = json.load(f)
    return data


def run_comparison_analysis(input_json: Path, api_key: str = None) -> dict:
    """Run comparison analysis using pre-generated anomaly data."""
    
    anomaly_data = load_anomalies_from_json(input_json)
    
    results = {
        "timestamp": datetime.now().isoformat(),
        "input_file": str(input_json),
        "rule_based": {},
        "ai_agent": {},
        "comparison": {}
    }
    
    # =========================================
    # PHASE 1: Process Rule-Based Results
    # =========================================
    print("=" * 60)
    print("PHASE 1: Loading Rule-Based Detection Results")
    print("=" * 60)
    
    raw_anomalies = anomaly_data.get("anomalies", [])
    total_anomalies = anomaly_data.get("total_anomalies", len(raw_anomalies))
    geographic_summary = anomaly_data.get("geographic_summary", {})
    
    # Get release info
    if raw_anomalies:
        current = raw_anomalies[0].get("release_current", "unknown")
        previous = raw_anomalies[0].get("release_previous", "unknown")
    else:
        current = "unknown"
        previous = "unknown"
    
    print(f"  Releases: {previous} -> {current}")
    print(f"  Total anomalies loaded: {total_anomalies}")
    print(f"  Geographic data available: {len(geographic_summary)} themes")
    
    # Categorize by severity
    critical = [a for a in raw_anomalies if a.get("severity") == "critical"]
    warnings = [a for a in raw_anomalies if a.get("severity") == "warning"]
    info = [a for a in raw_anomalies if a.get("severity") == "info"]
    
    # Group by theme
    by_theme = {}
    for a in raw_anomalies:
        theme = a.get("theme", "unknown")
        if theme not in by_theme:
            by_theme[theme] = {"critical": 0, "warning": 0, "info": 0, "anomalies": []}
        by_theme[theme][a.get("severity", "warning")] += 1
        by_theme[theme]["anomalies"].append(a)
    
    # Group by anomaly type
    by_type = {}
    for a in raw_anomalies:
        atype = a.get("anomaly_type", "unknown")
        if atype not in by_type:
            by_type[atype] = 0
        by_type[atype] += 1
    
    # Group by country
    by_country = {}
    for a in raw_anomalies:
        country = a.get("country")
        if country:
            if country not in by_country:
                by_country[country] = {"critical": 0, "warning": 0, "info": 0, "total": 0}
            by_country[country][a.get("severity", "warning")] += 1
            by_country[country]["total"] += 1
    
    top_countries = dict(sorted(by_country.items(), key=lambda x: x[1]["total"], reverse=True)[:20])
    
    results["rule_based"] = {
        "total_anomalies": total_anomalies,
        "critical_count": len(critical),
        "warning_count": len(warnings),
        "info_count": len(info),
        "by_theme": {k: {"critical": v["critical"], "warning": v["warning"], "info": v.get("info", 0)} for k, v in by_theme.items()},
        "by_type": by_type,
        "by_country": by_country,
        "top_countries": top_countries,
        "sample_anomalies": raw_anomalies[:20],
        "all_anomalies": raw_anomalies,
        "geographic_summary": geographic_summary
    }
    
    print(f"  Critical: {len(critical)}, Warnings: {len(warnings)}, Info: {len(info)}")
    print(f"  Countries affected: {len(by_country)}")
    
    # =========================================
    # PHASE 2: AI Agent Analysis
    # =========================================
    print("\n" + "=" * 60)
    print("PHASE 2: Running AI Agent Analysis")
    print("=" * 60)
    
    if not api_key and not os.environ.get("ANTHROPIC_API_KEY"):
        print("  No API key - using simulated AI response")
        ai_response = _get_simulated_ai_response(results["rule_based"])
    elif HAS_ANTHROPIC:
        client = Anthropic(api_key=api_key)
        ai_response = _get_real_ai_analysis(client, results["rule_based"], current, previous)
    else:
        print("  Anthropic library not installed - using simulated AI response")
        ai_response = _get_simulated_ai_response(results["rule_based"])
    
    results["ai_agent"] = ai_response
    
    print(f"  Patterns identified: {len(ai_response.get('patterns', []))}")
    print(f"  Root causes: {len(ai_response.get('root_causes', []))}")
    
    # =========================================
    # PHASE 3: Comparative Analysis
    # =========================================
    print("\n" + "=" * 60)
    print("PHASE 3: Generating Comparison")
    print("=" * 60)
    
    num_patterns = len(ai_response.get('patterns', []))
    noise_reduction = ((total_anomalies - num_patterns) / total_anomalies * 100) if total_anomalies > 0 else 0
    
    results["comparison"] = {
        "releases_compared": f"{previous} -> {current}",
        "signal_to_noise": {
            "rule_based": f"{total_anomalies} alerts",
            "ai_agent": f"{num_patterns} synthesized patterns"
        },
        "noise_reduction": f"{noise_reduction:.1f}%",
        "key_differences": [
            {
                "aspect": "Output Volume",
                "rule_based": f"{total_anomalies} individual alerts",
                "ai_agent": f"{num_patterns} grouped patterns + interpretation",
                "winner": "AI Agent"
            },
            {
                "aspect": "Root Cause Analysis",
                "rule_based": "None - only flags threshold violations",
                "ai_agent": "Identifies systematic issues and root causes",
                "winner": "AI Agent"
            },
            {
                "aspect": "Geographic Insights",
                "rule_based": "Lists affected countries",
                "ai_agent": "Identifies geographic patterns and concentrations",
                "winner": "AI Agent"
            },
            {
                "aspect": "Confidence Scores",
                "rule_based": "Binary (anomaly or not)",
                "ai_agent": "Per-pattern confidence scores",
                "winner": "AI Agent"
            },
            {
                "aspect": "Execution Speed",
                "rule_based": "~2-5 seconds",
                "ai_agent": "~10-15 seconds (includes API call)",
                "winner": "Rule-Based"
            },
            {
                "aspect": "Cost",
                "rule_based": "Free",
                "ai_agent": "~$0.02 per analysis",
                "winner": "Rule-Based"
            },
            {
                "aspect": "Determinism",
                "rule_based": "100% reproducible",
                "ai_agent": "May vary slightly between runs",
                "winner": "Rule-Based"
            }
        ]
    }
    
    return results


def _get_real_ai_analysis(client, rule_based_data: dict, current: str, previous: str) -> dict:
    """Get real AI analysis from Claude with enhanced prompt."""
    
    # Prepare comprehensive summary
    summary = {
        "releases": f"{previous} -> {current}",
        "total_anomalies": rule_based_data["total_anomalies"],
        "critical": rule_based_data["critical_count"],
        "warnings": rule_based_data["warning_count"],
        "info": rule_based_data.get("info_count", 0),
        "by_theme": rule_based_data["by_theme"],
        "by_type": rule_based_data["by_type"],
        "countries_affected": len(rule_based_data.get("by_country", {})),
        "top_countries": rule_based_data.get("top_countries", {}),
        "geographic_summary": rule_based_data.get("geographic_summary", {}),
        "sample_anomalies": rule_based_data["sample_anomalies"][:15]
    }
    
    prompt = f"""You are a geospatial data quality expert analyzing Overture Maps release anomalies.

CONTEXT:
- Overture Maps releases monthly updates of global geospatial data (buildings, places, roads, etc.)
- You're comparing release {previous} to {current}
- A rule-based detector found {summary['total_anomalies']} anomalies ({summary['critical']} critical, {summary['warnings']} warning)

RULE-BASED ANOMALY DATA:
```json
{json.dumps(summary, indent=2)}
```

YOUR TASK: Synthesize these alerts into actionable intelligence and discover any patterns the rules may have missed.

Respond with ONLY a valid JSON object (no markdown, no explanation outside JSON):

{{
  "executive_summary": "2-3 sentence summary of what happened, severity, and impact",
  
  "patterns": [
    {{
      "name": "Pattern name",
      "description": "What this pattern means",
      "affected_themes": ["theme1", "theme2"],
      "affected_countries": ["US", "DE"],
      "anomaly_count": 123,
      "severity": "CRITICAL|WARNING|INFO",
      "confidence": 0.85,
      "evidence": "Specific data points supporting this pattern"
    }}
  ],
  
  "root_causes": [
    {{
      "hypothesis": "What likely caused this",
      "likelihood": "HIGH|MEDIUM|LOW",
      "evidence": "Data supporting this hypothesis"
    }}
  ],
  
  "geographic_insights": [
    {{
      "finding": "Geographic pattern description",
      "countries": ["CN", "VN", "ID"],
      "interpretation": "What this means"
    }}
  ],
  
  "data_quality_assessment": {{
    "overall_rating": "CRITICAL|POOR|FAIR|GOOD",
    "key_concerns": ["concern1", "concern2"],
    "themes_most_affected": ["theme1", "theme2"]
  }},
  
  "recommended_actions": [
    {{
      "priority": "IMMEDIATE|SHORT_TERM|PREVENTIVE",
      "action": "What to do",
      "rationale": "Why this matters"
    }}
  ],
  
  "risk_assessment": {{
    "severity": "CRITICAL|HIGH|MEDIUM|LOW",
    "confidence": 0.9,
    "downstream_impact": "Who/what would be affected"
  }}
}}

IMPORTANT:
- Reference specific numbers from the data
- Group the {summary['total_anomalies']} alerts into distinct patterns (aim for 3-7 patterns)
- Provide confidence scores between 0.0 and 1.0
- Be specific about geographic patterns using the country data provided
- Do not hallucinate statistics not in the data"""

    response = client.messages.create(
        model="claude-sonnet-4-20250514",
        max_tokens=4000,
        temperature=0,
        messages=[{"role": "user", "content": prompt}]
    )
    
    response_text = response.content[0].text
    
    # Parse JSON response
    try:
        # Clean up response if needed
        response_text = response_text.strip()
        if response_text.startswith("```"):
            response_text = response_text.split("```")[1]
            if response_text.startswith("json"):
                response_text = response_text[4:]
        
        ai_response = json.loads(response_text)
        
        # Add token usage info
        ai_response["token_usage"] = {
            "input_tokens": response.usage.input_tokens,
            "output_tokens": response.usage.output_tokens
        }
        
        return ai_response
        
    except json.JSONDecodeError:
        # Return structured fallback
        return {
            "executive_summary": response_text[:500],
            "patterns": [{"name": "Analysis completed", "description": response_text, "confidence": 0.7}],
            "root_causes": [],
            "geographic_insights": [],
            "data_quality_assessment": {"overall_rating": "UNKNOWN", "key_concerns": []},
            "recommended_actions": [],
            "risk_assessment": {"severity": "UNKNOWN", "confidence": 0.5},
            "raw_response": response_text
        }


def _get_simulated_ai_response(rule_based_data: dict) -> dict:
    """Simulated AI response when no API key available."""
    total = rule_based_data["total_anomalies"]
    critical = rule_based_data["critical_count"]
    countries = len(rule_based_data.get("by_country", {}))
    by_type = rule_based_data.get("by_type", {})
    
    # Analyze patterns from the data
    patterns = []
    
    # Check for duplication pattern
    spike_count = by_type.get("feature_count_spike", 0)
    if spike_count > 10:
        patterns.append({
            "name": "Systematic Feature Duplication",
            "description": f"~100% increases detected across multiple themes, suggesting data was processed twice",
            "affected_themes": ["divisions", "transportation"],
            "affected_countries": list(rule_based_data.get("top_countries", {}).keys())[:5],
            "anomaly_count": spike_count,
            "severity": "CRITICAL",
            "confidence": 0.92,
            "evidence": f"{spike_count} feature_count_spike anomalies detected"
        })
    
    # Check for coverage issues
    coverage_drop = by_type.get("attribute_coverage_drop", 0) + by_type.get("low_attribute_coverage", 0)
    if coverage_drop > 0:
        patterns.append({
            "name": "Attribute Coverage Degradation",
            "description": "Required fields showing increased null rates or low coverage",
            "affected_themes": ["places", "addresses"],
            "anomaly_count": coverage_drop,
            "severity": "WARNING",
            "confidence": 0.78,
            "evidence": f"{coverage_drop} coverage-related anomalies"
        })
    
    # Check for geographic concentration
    geo_concentration = by_type.get("geographic_concentration", 0)
    if geo_concentration > 0:
        patterns.append({
            "name": "Geographically Concentrated Changes",
            "description": "Changes heavily concentrated in specific regions",
            "affected_countries": list(rule_based_data.get("top_countries", {}).keys())[:3],
            "anomaly_count": geo_concentration,
            "severity": "INFO",
            "confidence": 0.73,
            "evidence": "Geographic concentration detected in rule-based analysis"
        })
    
    # Check for data quality issues
    quality_issues = by_type.get("data_quality_degradation", 0) + by_type.get("high_removal_rate", 0)
    if quality_issues > 0:
        patterns.append({
            "name": "Data Quality Degradation",
            "description": "High modification rates or removal rates detected",
            "anomaly_count": quality_issues,
            "severity": "WARNING",
            "confidence": 0.75,
            "evidence": f"{quality_issues} data quality anomalies"
        })
    
    if not patterns:
        patterns.append({
            "name": "Multiple Data Quality Issues",
            "description": f"{total} anomalies detected across various categories",
            "anomaly_count": total,
            "severity": "WARNING" if critical < total * 0.5 else "CRITICAL",
            "confidence": 0.70
        })
    
    return {
        "executive_summary": f"The Overture Maps release shows {total} anomalies ({critical} critical) affecting {countries} countries. {'Systematic issues detected requiring immediate attention.' if critical > 100 else 'Moderate data quality concerns identified.'}",
        
        "patterns": patterns,
        
        "root_causes": [
            {
                "hypothesis": "Data pipeline duplication or merge error",
                "likelihood": "HIGH" if spike_count > 50 else "MEDIUM",
                "evidence": f"{spike_count} spike anomalies with ~100% increases"
            },
            {
                "hypothesis": "Data source integration changes",
                "likelihood": "MEDIUM",
                "evidence": "Geographic concentration suggests regional data source issues"
            }
        ],
        
        "geographic_insights": [
            {
                "finding": f"Changes concentrated in top countries",
                "countries": list(rule_based_data.get("top_countries", {}).keys())[:5],
                "interpretation": "May indicate regional data source updates or issues"
            }
        ],
        
        "data_quality_assessment": {
            "overall_rating": "CRITICAL" if critical > 100 else "POOR" if critical > 20 else "FAIR",
            "key_concerns": [
                f"{critical} critical anomalies",
                f"{countries} countries affected",
                "Potential systematic duplication" if spike_count > 50 else "Various data quality issues"
            ],
            "themes_most_affected": list(rule_based_data.get("by_theme", {}).keys())[:3]
        },
        
        "recommended_actions": [
            {
                "priority": "IMMEDIATE",
                "action": "Investigate critical anomalies before release",
                "rationale": f"{critical} critical issues could impact downstream users"
            },
            {
                "priority": "SHORT_TERM",
                "action": "Audit data pipeline for duplication logic",
                "rationale": "Pattern suggests systematic processing issue"
            },
            {
                "priority": "PREVENTIVE",
                "action": "Implement automated duplicate detection",
                "rationale": "Catch similar issues before they reach production"
            }
        ],
        
        "risk_assessment": {
            "severity": "CRITICAL" if critical > 100 else "HIGH" if critical > 20 else "MEDIUM",
            "confidence": 0.85,
            "downstream_impact": "Map applications, geocoding services, navigation systems"
        }
    }


def generate_comparison_dashboard(results: dict, output_path: Path) -> str:
    """Generate the HTML comparison dashboard."""
    
    rb = results["rule_based"]
    ai = results["ai_agent"]
    comp = results["comparison"]
    
    def _find_anomalies_for_pattern(pattern_name: str, all_anomalies: list) -> list:
        """Find anomalies that match a pattern name."""
        pattern_lower = pattern_name.lower()
        
        # Define pattern-to-filter mappings
        filters = []
        if 'division' in pattern_lower:
            filters.append(lambda a: a.get('theme') == 'divisions')
        if 'explosion' in pattern_lower or 'spike' in pattern_lower or 'surge' in pattern_lower:
            filters.append(lambda a: a.get('anomaly_type') == 'feature_count_spike' or 
                          a.get('anomaly_type') == 'net_feature_gain' or
                          a.get('anomaly_type') == 'high_addition_rate')
        if 'coverage' in pattern_lower or 'attribute' in pattern_lower:
            filters.append(lambda a: 'coverage' in a.get('anomaly_type', ''))
        if 'geometry' in pattern_lower:
            filters.append(lambda a: 'geometry' in a.get('anomaly_type', ''))
        if 'infrastructure' in pattern_lower:
            filters.append(lambda a: a.get('type') == 'infrastructure')
        if 'transportation' in pattern_lower:
            filters.append(lambda a: a.get('theme') == 'transportation')
        if 'building' in pattern_lower:
            filters.append(lambda a: a.get('theme') == 'buildings')
        if 'place' in pattern_lower:
            filters.append(lambda a: a.get('theme') == 'places')
        if 'regeneration' in pattern_lower or 'rebuild' in pattern_lower:
            filters.append(lambda a: a.get('anomaly_type') == 'data_regeneration')
        if 'quality' in pattern_lower:
            filters.append(lambda a: 'quality' in a.get('anomaly_type', '') or 
                          a.get('anomaly_type') == 'high_removal_rate')
        
        if not filters:
            return all_anomalies[:10]  # Return sample if no specific match
        
        # Apply filters (OR logic)
        matching = []
        for a in all_anomalies:
            for f in filters:
                if f(a):
                    matching.append(a)
                    break
        
        return matching
    
    # Prepare data for charts
    top_countries = rb.get("top_countries", {})
    country_labels = list(top_countries.keys())
    country_critical = [top_countries[c].get("critical", 0) for c in country_labels]
    country_warning = [top_countries[c].get("warning", 0) for c in country_labels]
    
    # Prepare patterns HTML
    patterns_html = ""
    for p in ai.get("patterns", []):
        severity = p.get("severity", "INFO")
        severity_color = "red" if severity == "CRITICAL" else "yellow" if severity == "WARNING" else "blue"
        confidence = p.get("confidence", 0.5)
        pattern_name = p.get('name', 'Pattern')
        pattern_id = pattern_name.lower().replace(' ', '_').replace('/', '_')
        
        # Find matching anomalies for this pattern
        pattern_anomalies = _find_anomalies_for_pattern(pattern_name, rb.get('all_anomalies', []))
        anomaly_sample = pattern_anomalies[:10]  # Show first 10
        
        # Build anomaly details HTML
        anomaly_details_html = ""
        if anomaly_sample:
            anomaly_details_html = f"""
            <div id="details_{pattern_id}" class="hidden mt-4 border-t pt-4">
                <h5 class="font-semibold text-sm mb-2">Sample Anomalies ({len(pattern_anomalies)} total):</h5>
                <div class="max-h-64 overflow-y-auto">
                    <table class="w-full text-xs">
                        <thead class="bg-gray-100">
                            <tr>
                                <th class="px-2 py-1 text-left">Theme/Type</th>
                                <th class="px-2 py-1 text-left">Country</th>
                                <th class="px-2 py-1 text-left">Column</th>
                                <th class="px-2 py-1 text-left">Description</th>
                                <th class="px-2 py-1 text-right">Change</th>
                            </tr>
                        </thead>
                        <tbody>
            """
            for a in anomaly_sample:
                anomaly_details_html += f"""
                            <tr class="border-b border-gray-100">
                                <td class="px-2 py-1">{a.get('theme', '')}/{a.get('type', '')}</td>
                                <td class="px-2 py-1">{a.get('country', '-')}</td>
                                <td class="px-2 py-1">{a.get('column', '-')}</td>
                                <td class="px-2 py-1 max-w-xs truncate" title="{a.get('description', '')}">{a.get('description', '')[:50]}...</td>
                                <td class="px-2 py-1 text-right">{a.get('percent_change', 0):.1f}%</td>
                            </tr>
                """
            anomaly_details_html += """
                        </tbody>
                    </table>
                </div>
                <p class="text-xs text-gray-400 mt-2">Use anomaly_explorer.py to see all anomalies and source files</p>
            </div>
            """
        
        patterns_html += f"""
        <div class="bg-white border-l-4 border-{severity_color}-500 p-4 mb-4 rounded-r-lg shadow">
            <div class="flex justify-between items-start">
                <h4 class="font-semibold text-lg">{pattern_name}</h4>
                <span class="px-2 py-1 bg-{severity_color}-100 text-{severity_color}-800 rounded text-sm">{severity}</span>
            </div>
            <p class="text-gray-600 mt-2">{p.get('description', '')}</p>
            <div class="mt-2 flex gap-4 text-sm text-gray-500">
                <span>Confidence: {confidence*100:.0f}%</span>
                <span>Anomalies: {p.get('anomaly_count', 'N/A')}</span>
            </div>
            <p class="text-sm text-gray-500 mt-1">Evidence: {p.get('evidence', 'N/A')}</p>
            <button onclick="toggleDetails('details_{pattern_id}')" class="mt-2 text-sm text-blue-600 hover:text-blue-800">
                ▶ Show underlying anomalies
            </button>
            {anomaly_details_html}
        </div>
        """
    
    # Prepare actions HTML
    actions_html = ""
    for a in ai.get("recommended_actions", []):
        priority = a.get("priority", "")
        priority_color = "red" if priority == "IMMEDIATE" else "yellow" if priority == "SHORT_TERM" else "blue"
        actions_html += f"""
        <div class="flex items-start gap-3 mb-3">
            <span class="px-2 py-1 bg-{priority_color}-100 text-{priority_color}-800 rounded text-xs font-semibold">{priority}</span>
            <div>
                <p class="font-medium">{a.get('action', '')}</p>
                <p class="text-sm text-gray-500">{a.get('rationale', '')}</p>
            </div>
        </div>
        """
    
    # Root causes HTML
    root_causes_html = ""
    for rc in ai.get("root_causes", []):
        likelihood = rc.get("likelihood", "MEDIUM")
        likelihood_color = "red" if likelihood == "HIGH" else "yellow" if likelihood == "MEDIUM" else "gray"
        root_causes_html += f"""
        <div class="mb-4 p-3 bg-gray-50 rounded-lg">
            <div class="flex justify-between">
                <span class="font-medium">{rc.get('hypothesis', '')}</span>
                <span class="text-sm px-2 py-1 bg-{likelihood_color}-100 rounded">{likelihood}</span>
            </div>
            <p class="text-sm text-gray-500 mt-1">{rc.get('evidence', '')}</p>
        </div>
        """
    
    # Geographic insights HTML
    geo_insights_html = ""
    for gi in ai.get("geographic_insights", []):
        countries_badges = "".join([f'<span class="px-2 py-1 bg-blue-100 text-blue-800 rounded text-xs mr-1">{c}</span>' for c in gi.get('countries', [])[:5]])
        geo_insights_html += f"""
        <div class="mb-4 p-3 bg-blue-50 rounded-lg">
            <p class="font-medium">{gi.get('finding', '')}</p>
            <p class="text-sm text-gray-600 mt-1">{gi.get('interpretation', '')}</p>
            <div class="flex gap-2 mt-2">{countries_badges}</div>
        </div>
        """
    
    # Risk assessment
    risk = ai.get("risk_assessment", {})
    risk_severity = risk.get("severity", "MEDIUM")
    risk_color = "red" if risk_severity == "CRITICAL" else "orange" if risk_severity == "HIGH" else "yellow" if risk_severity == "MEDIUM" else "green"
    
    # Data quality assessment
    dq = ai.get("data_quality_assessment", {})
    dq_rating = dq.get("overall_rating", "UNKNOWN")
    concerns_html = "".join([f'<li class="mb-1">• {c}</li>' for c in dq.get("key_concerns", [])])
    themes_html = "".join([f'<span class="px-2 py-1 bg-red-100 text-red-800 rounded text-sm mr-1">{t}</span>' for t in dq.get("themes_most_affected", [])])
    
    html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Overture Maps Anomaly Analysis Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .gradient-header {{
            background: linear-gradient(135deg, #1e3a5f 0%, #2d5a87 100%);
        }}
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <!-- Header -->
    <div class="gradient-header text-white py-8 px-4 mb-8">
        <div class="container mx-auto">
            <h1 class="text-4xl font-bold mb-2">Overture Maps Anomaly Analysis</h1>
            <p class="text-xl opacity-90">Rule-Based Detection + AI Agent Synthesis</p>
            <p class="text-sm opacity-75 mt-2">
                Releases: <span class="font-mono bg-white/20 px-2 py-1 rounded">{comp['releases_compared']}</span>
                | Generated: {results['timestamp'][:10]}
            </p>
        </div>
    </div>
    
    <div class="container mx-auto px-4 pb-12">
        
        <!-- Executive Summary -->
        <div class="bg-white rounded-xl shadow-lg p-6 mb-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Executive Summary</h2>
            <p class="text-lg text-gray-700 mb-6">{ai.get('executive_summary', 'Analysis complete.')}</p>
            
            <div class="grid grid-cols-1 md:grid-cols-5 gap-4">
                <div class="text-center p-4 bg-blue-50 rounded-lg">
                    <div class="text-4xl font-bold text-blue-600">{rb['total_anomalies']}</div>
                    <div class="text-gray-600 text-sm">Rule-Based Alerts</div>
                </div>
                <div class="text-center p-4 bg-green-50 rounded-lg">
                    <div class="text-4xl font-bold text-green-600">{len(ai.get('patterns', []))}</div>
                    <div class="text-gray-600 text-sm">AI Patterns</div>
                </div>
                <div class="text-center p-4 bg-purple-50 rounded-lg">
                    <div class="text-4xl font-bold text-purple-600">{comp['noise_reduction']}</div>
                    <div class="text-gray-600 text-sm">Noise Reduction</div>
                </div>
                <div class="text-center p-4 bg-red-50 rounded-lg">
                    <div class="text-4xl font-bold text-red-600">{rb['critical_count']}</div>
                    <div class="text-gray-600 text-sm">Critical Issues</div>
                </div>
                <div class="text-center p-4 bg-orange-50 rounded-lg">
                    <div class="text-4xl font-bold text-orange-600">{len(rb.get('by_country', {}))}</div>
                    <div class="text-gray-600 text-sm">Countries Affected</div>
                </div>
            </div>
        </div>
        
        <!-- Risk Assessment Banner -->
        <div class="bg-{risk_color}-100 border border-{risk_color}-300 rounded-xl p-6 mb-8">
            <div class="flex items-center justify-between">
                <div>
                    <h3 class="text-xl font-bold text-{risk_color}-800">Risk Assessment: {risk_severity}</h3>
                    <p class="text-{risk_color}-700">{risk.get('downstream_impact', '')}</p>
                </div>
                <div class="text-right">
                    <div class="text-3xl font-bold text-{risk_color}-600">{risk.get('confidence', 0)*100:.0f}%</div>
                    <div class="text-sm text-{risk_color}-600">Confidence</div>
                </div>
            </div>
        </div>
        
        <!-- AI Patterns -->
        <div class="bg-white rounded-xl shadow-lg p-6 mb-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">AI-Identified Patterns</h2>
            <p class="text-gray-600 mb-4">The AI agent synthesized {rb['total_anomalies']} rule-based alerts into {len(ai.get('patterns', []))} actionable patterns:</p>
            {patterns_html if patterns_html else '<p class="text-gray-500">No patterns identified</p>'}
        </div>
        
        <!-- Two Column: Root Causes + Actions -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
            <!-- Root Causes -->
            <div class="bg-white rounded-xl shadow-lg p-6">
                <h3 class="text-xl font-bold text-gray-800 mb-4">Root Cause Hypotheses</h3>
                {root_causes_html if root_causes_html else '<p class="text-gray-500">No root causes identified</p>'}
            </div>
            
            <!-- Recommended Actions -->
            <div class="bg-white rounded-xl shadow-lg p-6">
                <h3 class="text-xl font-bold text-gray-800 mb-4">Recommended Actions</h3>
                {actions_html if actions_html else '<p class="text-gray-500">No actions recommended</p>'}
            </div>
        </div>
        
        <!-- Geographic Insights -->
        <div class="bg-white rounded-xl shadow-lg p-6 mb-8">
            <h3 class="text-xl font-bold text-gray-800 mb-4">Geographic Insights</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    {geo_insights_html if geo_insights_html else '<p class="text-gray-500">No geographic patterns identified</p>'}
                </div>
                <div style="height: 300px;">
                    <canvas id="countryChart"></canvas>
                </div>
            </div>
        </div>
        
        <!-- Charts Row -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-8">
            <div class="bg-white rounded-xl shadow-lg p-6">
                <h3 class="text-lg font-semibold mb-4">Anomalies by Theme</h3>
                <canvas id="themeChart"></canvas>
            </div>
            <div class="bg-white rounded-xl shadow-lg p-6">
                <h3 class="text-lg font-semibold mb-4">Anomalies by Type</h3>
                <canvas id="typeChart"></canvas>
            </div>
        </div>
        
        <!-- Comparison Table -->
        <div class="bg-white rounded-xl shadow-lg p-6 mb-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Rule-Based vs AI Agent Comparison</h2>
            <div class="overflow-x-auto">
                <table class="w-full">
                    <thead>
                        <tr class="border-b-2 border-gray-200">
                            <th class="text-left py-3 px-4">Aspect</th>
                            <th class="text-left py-3 px-4 text-blue-600">Rule-Based</th>
                            <th class="text-left py-3 px-4 text-green-600">AI Agent</th>
                            <th class="text-center py-3 px-4">Winner</th>
                        </tr>
                    </thead>
                    <tbody>
                        {"".join([f'''
                        <tr class="border-b border-gray-100">
                            <td class="py-3 px-4 font-medium">{d['aspect']}</td>
                            <td class="py-3 px-4 text-sm">{d['rule_based']}</td>
                            <td class="py-3 px-4 text-sm">{d['ai_agent']}</td>
                            <td class="py-3 px-4 text-center">
                                <span class="px-3 py-1 rounded-full text-xs font-semibold {'bg-blue-100 text-blue-800' if d['winner'] == 'Rule-Based' else 'bg-green-100 text-green-800'}">
                                    {d['winner']}
                                </span>
                            </td>
                        </tr>
                        ''' for d in comp['key_differences']])}
                    </tbody>
                </table>
            </div>
        </div>
        
        <!-- Data Quality Assessment -->
        <div class="bg-white rounded-xl shadow-lg p-6 mb-8">
            <h3 class="text-xl font-bold text-gray-800 mb-4">Data Quality Assessment</h3>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div class="text-center p-4 bg-gray-50 rounded-lg">
                    <div class="text-2xl font-bold">{dq_rating}</div>
                    <div class="text-gray-600">Overall Rating</div>
                </div>
                <div class="p-4">
                    <h4 class="font-semibold mb-2">Key Concerns</h4>
                    <ul class="text-sm text-gray-600">{concerns_html}</ul>
                </div>
                <div class="p-4">
                    <h4 class="font-semibold mb-2">Most Affected Themes</h4>
                    <div class="flex flex-wrap gap-2">{themes_html}</div>
                </div>
            </div>
        </div>
        
    </div>
    
    <script>
        // Toggle function for showing/hiding anomaly details
        function toggleDetails(elementId) {{
            const el = document.getElementById(elementId);
            if (el) {{
                el.classList.toggle('hidden');
                const btn = el.previousElementSibling;
                if (btn && btn.tagName === 'BUTTON') {{
                    btn.textContent = el.classList.contains('hidden') 
                        ? '▶ Show underlying anomalies' 
                        : '▼ Hide underlying anomalies';
                }}
            }}
        }}
        
        // Theme chart
        const themeData = {json.dumps(rb['by_theme'])};
        const themeLabels = Object.keys(themeData);
        const themeCritical = themeLabels.map(t => themeData[t].critical || 0);
        const themeWarning = themeLabels.map(t => themeData[t].warning || 0);
        
        new Chart(document.getElementById('themeChart'), {{
            type: 'bar',
            data: {{
                labels: themeLabels,
                datasets: [
                    {{ label: 'Critical', data: themeCritical, backgroundColor: '#dc2626' }},
                    {{ label: 'Warning', data: themeWarning, backgroundColor: '#f59e0b' }}
                ]
            }},
            options: {{
                responsive: true,
                scales: {{ x: {{ stacked: true }}, y: {{ stacked: true, beginAtZero: true }} }}
            }}
        }});
        
        // Type chart
        const typeData = {json.dumps(rb['by_type'])};
        new Chart(document.getElementById('typeChart'), {{
            type: 'doughnut',
            data: {{
                labels: Object.keys(typeData),
                datasets: [{{
                    data: Object.values(typeData),
                    backgroundColor: ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899', '#06b6d4', '#84cc16']
                }}]
            }},
            options: {{ responsive: true }}
        }});
        
        // Country chart
        const countryLabels = {json.dumps(country_labels)};
        const countryCritical = {json.dumps(country_critical)};
        const countryWarning = {json.dumps(country_warning)};
        
        new Chart(document.getElementById('countryChart'), {{
            type: 'bar',
            data: {{
                labels: countryLabels,
                datasets: [
                    {{ label: 'Critical', data: countryCritical, backgroundColor: '#dc2626' }},
                    {{ label: 'Warning', data: countryWarning, backgroundColor: '#f59e0b' }}
                ]
            }},
            options: {{
                responsive: true,
                maintainAspectRatio: false,
                indexAxis: 'y',
                scales: {{ x: {{ stacked: true }}, y: {{ stacked: true }} }}
            }}
        }});
    </script>
    
    <!-- Chat Panel -->
    <div id="chatPanel" class="fixed bottom-4 right-4 z-50">
        <!-- Chat Toggle Button -->
        <button id="chatToggle" onclick="toggleChat()" 
                class="bg-blue-600 hover:bg-blue-700 text-white rounded-full p-4 shadow-lg">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z" />
            </svg>
        </button>
        
        <!-- Chat Window -->
        <div id="chatWindow" class="hidden absolute bottom-16 right-0 w-96 bg-white rounded-lg shadow-2xl border border-gray-200">
            <div class="bg-blue-600 text-white p-3 rounded-t-lg flex justify-between items-center">
                <span class="font-semibold">Ask about anomalies</span>
                <button onclick="toggleChat()" class="text-white hover:text-gray-200">&times;</button>
            </div>
            
            <div id="chatMessages" class="h-80 overflow-y-auto p-4 space-y-3">
                <div class="bg-gray-100 rounded-lg p-3 text-sm">
                    <p class="font-medium text-gray-700">AI Assistant</p>
                    <p class="text-gray-600">Ask me questions about the anomalies, like:</p>
                    <ul class="text-gray-500 text-xs mt-1 list-disc list-inside">
                        <li>Which countries are most affected?</li>
                        <li>What should I prioritize fixing?</li>
                        <li>Explain the duplication pattern</li>
                        <li>What files should I check?</li>
                    </ul>
                </div>
            </div>
            
            <div class="border-t p-3">
                <div class="flex gap-2">
                    <input type="text" id="chatInput" 
                           placeholder="Ask a question..." 
                           class="flex-1 border rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                           onkeypress="if(event.key==='Enter')sendMessage()">
                    <button onclick="sendMessage()" 
                            class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm">
                        Send
                    </button>
                </div>
                <p id="chatStatus" class="text-xs text-gray-400 mt-1 hidden">Thinking...</p>
            </div>
        </div>
    </div>
    
    <script>
        // Chat functionality
        const anomalyContext = {json.dumps({
            'summary': ai.get('executive_summary', ''),
            'patterns': ai.get('patterns', []),
            'root_causes': ai.get('root_causes', []),
            'total_anomalies': rb.get('total_anomalies', 0),
            'critical_count': rb.get('by_severity', {}).get('critical', 0),
            'by_theme': rb.get('by_theme', {}),
            'by_type': rb.get('by_type', {}),
            'top_countries': rb.get('top_countries', {}),
            'recommended_actions': ai.get('recommended_actions', [])
        })};
        
        let chatHistory = [];
        
        function toggleChat() {{
            const chatWindow = document.getElementById('chatWindow');
            chatWindow.classList.toggle('hidden');
        }}
        
        function addMessage(content, isUser) {{
            const messagesDiv = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = isUser 
                ? 'bg-blue-100 rounded-lg p-3 text-sm ml-8' 
                : 'bg-gray-100 rounded-lg p-3 text-sm mr-8';
            messageDiv.innerHTML = `
                <p class="font-medium ${{isUser ? 'text-blue-700' : 'text-gray-700'}}">${{isUser ? 'You' : 'AI Assistant'}}</p>
                <p class="text-gray-600 whitespace-pre-wrap">${{content}}</p>
            `;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }}
        
        async function sendMessage() {{
            const input = document.getElementById('chatInput');
            const status = document.getElementById('chatStatus');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Add user message
            addMessage(message, true);
            input.value = '';
            status.classList.remove('hidden');
            
            // Build prompt with context
            const systemPrompt = `You are an AI assistant helping analyze Overture Maps release anomalies. 
            
Here is the context about the current anomaly analysis:

Executive Summary: ${{anomalyContext.summary}}

Total Anomalies: ${{anomalyContext.total_anomalies}}
Critical: ${{anomalyContext.critical_count}}

Patterns Identified:
${{JSON.stringify(anomalyContext.patterns, null, 2)}}

Root Causes:
${{JSON.stringify(anomalyContext.root_causes, null, 2)}}

By Theme: ${{JSON.stringify(anomalyContext.by_theme)}}
By Type: ${{JSON.stringify(anomalyContext.by_type)}}
Top Countries: ${{JSON.stringify(anomalyContext.top_countries)}}

Recommended Actions:
${{JSON.stringify(anomalyContext.recommended_actions, null, 2)}}

Answer the user's question concisely based on this context. If asked about files to check, suggest looking at the metrics files for the relevant theme/type.`;

            chatHistory.push({{ role: 'user', content: message }});
            
            try {{
                const response = await fetch('https://api.anthropic.com/v1/messages', {{
                    method: 'POST',
                    headers: {{
                        'Content-Type': 'application/json',
                        'x-api-key': localStorage.getItem('anthropic_api_key') || '',
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    }},
                    body: JSON.stringify({{
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 1024,
                        system: systemPrompt,
                        messages: chatHistory
                    }})
                }});
                
                if (!response.ok) {{
                    if (response.status === 401) {{
                        const apiKey = prompt('Enter your Anthropic API key for chat:');
                        if (apiKey) {{
                            localStorage.setItem('anthropic_api_key', apiKey);
                            addMessage('API key saved. Please try your question again.', false);
                        }} else {{
                            addMessage('Chat requires an API key. Enter it when prompted.', false);
                        }}
                    }} else {{
                        throw new Error(`API error: ${{response.status}}`);
                    }}
                    status.classList.add('hidden');
                    return;
                }}
                
                const data = await response.json();
                const assistantMessage = data.content[0].text;
                
                chatHistory.push({{ role: 'assistant', content: assistantMessage }});
                addMessage(assistantMessage, false);
                
            }} catch (error) {{
                addMessage(`Error: ${{error.message}}. Make sure you have a valid API key.`, false);
            }}
            
            status.classList.add('hidden');
        }}
    </script>
    
    <footer class="bg-gray-800 text-white py-6">
        <div class="container mx-auto px-4 text-center text-sm opacity-75">
            Overture Maps Anomaly Detection System | Generated: {results['timestamp']}
        </div>
    </footer>
</body>
</html>"""
    
    output_path.write_text(html)
    return html


def main():
    """Main entry point."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Generate AI-powered anomaly analysis dashboard")
    parser.add_argument("--input", "-i", type=Path, required=True, help="JSON file from anomaly_detector.py")
    parser.add_argument("--output", "-o", type=Path, default=Path("dashboard.html"))
    parser.add_argument("--json-output", type=Path, help="Also save analysis results as JSON")
    
    args = parser.parse_args()
    
    if not args.input.exists():
        print(f"Error: Input file not found: {args.input}")
        return
    
    print("Running AI Analysis...")
    print(f"Input: {args.input}")
    print()
    
    results = run_comparison_analysis(args.input)
    
    print("\n" + "=" * 60)
    print("Generating Dashboard...")
    print("=" * 60)
    
    generate_comparison_dashboard(results, args.output)
    
    if args.json_output:
        # Remove large data before saving
        results_slim = {k: v for k, v in results.items()}
        results_slim["rule_based"] = {k: v for k, v in results["rule_based"].items() if k not in ["all_anomalies"]}
        args.json_output.write_text(json.dumps(results_slim, indent=2, default=str))
        print(f"JSON saved to: {args.json_output}")
    
    print(f"Dashboard saved to: {args.output}")
    print(f"\nOpen in browser: file://{args.output.absolute()}")


if __name__ == "__main__":
    main()